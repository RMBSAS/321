<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Задание 18 — Практика</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../assets/style.css" />
</head>
<body>
  <h1>Задание 18 — Практика</h1>
  <nav>
    <a href="../../index.html">На главную</a> |
    <a href="teoria.html">Теория</a>
  </nav>
  <section>
    <h2>Практическое задание</h2>
    <p>
      Квадрат N×N (1 &lt; N &lt; 30) разбит на клетки, между некоторыми клетками и по границе проведены стены.
      Исполнитель «Робот» может ходить вправо или вниз на соседнюю клетку (если нет стены).
      В каждой клетке лежит монета (стоимость 1–100). Робот стартует в левой верхней клетке и идёт до одной из «угловых» клеток (тех, которые ограничены справа и снизу стенами).
    </p>
    <p>
      По пути Робот собирает монеты. Определите максимальную и минимальную суммы монет, которые может собрать Робот (сначала максимальную, потом минимальную).
    </p>

    <h2>Решение на Python</h2>
    <pre><code># Загрузка данных
N = 5  # Пример значения
coins = [
    [1, 2, 3, 4, 5],
    [6, 7, 8, 9, 10],
    [11, 12, 13, 14, 15],
    [16, 17, 18, 19, 20],
    [21, 22, 23, 24, 25]
]
# Примерные стены (0 — можно идти, 1 — стена)
walls_right = [[0]*N for _ in range(N)]
walls_down = [[0]*N for _ in range(N)]
# Можно задать стены по данным задачи

# Динамика: минимальная и максимальная сумма
min_dp = [[float('inf')]*N for _ in range(N)]
max_dp = [[0]*N for _ in range(N)]

min_dp[0][0] = max_dp[0][0] = coins[0][0]

for i in range(N):
    for j in range(N):
        if i > 0 and walls_down[i-1][j] == 0:
            min_dp[i][j] = min(min_dp[i][j], min_dp[i-1][j] + coins[i][j])
            max_dp[i][j] = max(max_dp[i][j], max_dp[i-1][j] + coins[i][j])
        if j > 0 and walls_right[i][j-1] == 0:
            min_dp[i][j] = min(min_dp[i][j], min_dp[i][j-1] + coins[i][j])
            max_dp[i][j] = max(max_dp[i][j], max_dp[i][j-1] + coins[i][j])

# Поиск угловых клеток (вправо и вниз стены)
results = []
for i in range(N):
    for j in range(N):
        if walls_right[i][j] == 1 and walls_down[i][j] == 1:
            results.append((max_dp[i][j], min_dp[i][j]))

if results:
    max_sum = max(r[0] for r in results)
    min_sum = min(r[1] for r in results)
    print(max_sum, min_sum)
else:
    print("Нет допустимых конечных клеток")</code></pre>
    <p>Замените <code>N</code>, <code>coins</code> и стены на актуальные данные из вашей задачи.</p>
  </section>
</body>
</html>