<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Задание 1 — Практика</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../assets/style.css">
</head>
<body>
  <h1>Задание 1 — Практика</h1>
  <nav>
    <a href="../../index.html">На главную</a> |
    <a href="teoria.html">Теория</a>
  </nav>
  <section>
    <h2>Практическое задание</h2>
    <p>В приведённой схеме дорог N-го района каждому населённому пункту соответствует номер в таблице. Отсутствие дороги отмечено «*». Определите, какие номера в таблице могут соответствовать пунктам <strong>E</strong> и <strong>F</strong> на схеме. В ответе запишите эти два номера в возрастающем порядке (без пробелов и знаков препинания).</p>
    <h2>Решение на Python</h2>
    <pre><code># Пример решения
# Представим таблицу смежности в виде словаря:
adj = {
    1: [2, 3],
    2: [1, 4],
    3: [1, 4, 5],
    4: [2, 3, 5],
    5: [3, 4, 6],
    6: [5]
}

# В схеме точки E и F соединены со следующими узлами:
# E соединена с 2 и 3, F соединена с 4 и 5
need = {
    'E': {2, 3},
    'F': {4, 5}
}

# Функция для поиска номера по соседям

def find_node(neighbors_set):
    for node, neigh in adj.items():
        if set(neigh) == neighbors_set:
            return node
    return None

node_E = find_node(need['E'])
node_F = find_node(need['F'])

print(f"{min(node_E, node_F)}{max(node_E, node_F)}")  # Вывод без пробелов и разделителей
</code></pre>
  </section>
</body>
</html>
